{"map":"{\"version\":3,\"file\":\"CancelToken.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/cancel/CancelToken.ts\"],\"names\":[],\"mappings\":\"AACA,OAAO,MAAM,MAAM,UAAU,CAAC;AAO9B;;GAEG;AACH;IAGI,8EAA8E;IAC9E,qBAAY,QAAwB;QAApC,iBAmBC;QAlBG,OAAO;QACP,IAAI,cAA8B,CAAC;QACnC,yDAAyD;QACzD,wBAAwB;QACxB,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAS,UAAA,OAAO;YACtC,8CAA8C;YAC9C,cAAc,GAAG,OAAO,CAAC;QAC7B,CAAC,CAAC,CAAC;QACH,uEAAuE;QACvE,QAAQ,CAAC,UAAA,OAAO;YACZ,uBAAuB;YACvB,IAAI,KAAI,CAAC,MAAM,EAAE;gBACb,OAAO;aACV;YACD,KAAI,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,yBAAyB;YAC5D,sBAAsB;YACtB,cAAc,CAAC,KAAI,CAAC,MAAM,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;IACP,CAAC;IACD;;;OAGG;IACI,kBAAM,GAAb;QACI,yBAAyB;QACzB,IAAI,MAAiB,CAAC;QACtB,yCAAyC;QACzC,IAAM,KAAK,GAAG,IAAI,WAAW,CAAC,UAAA,CAAC;YAC3B,MAAM,GAAG,CAAC,CAAC,CAAC,oBAAoB;QACpC,CAAC,CAAC,CAAC;QACH,OAAO;YACH,KAAK,OAAA;YACL,MAAM,QAAA;SACT,CAAA;IACL,CAAC;IACD;;OAEG;IACH,sCAAgB,GAAhB;QACI,iDAAiD;QACjD,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,MAAM,IAAI,CAAC,MAAM,CAAC;SACrB;IACL,CAAC;IACL,kBAAC;AAAD,CAAC,AAjDD,IAiDC\"}","code":"import Cancel from './Cancel';\r\n/**\r\n * 取消token的类\r\n */\r\nvar CancelToken = /** @class */ (function () {\r\n    // 当外部实例化这个CancelToken的时候并传入executor，然后就会调用方法,executor，这个方法获取到一个为参数，然后执行这个方法即可\r\n    function CancelToken(executor) {\r\n        var _this = this;\r\n        // 临时变量\r\n        var resolvePromise;\r\n        // 实例化promise 这时候就执行了Promise，自动给resolvePromise赋值resolve方法\r\n        // 同时把结果返回给了this.promise\r\n        this.promise = new Promise(function (resolve) {\r\n            // 指向，然后调用resolvePromise的时候就是调用promise的resolve\r\n            resolvePromise = resolve;\r\n        });\r\n        // 调用执行者方法，传入一个回调函数，获取这个返回的方法，执行后，this.promise就会拥有this.reason这个Cancel对象\r\n        executor(function (message) {\r\n            // 防止多次调用,当这个有值得时候别重复调用\r\n            if (_this.reason) {\r\n                return;\r\n            }\r\n            _this.reason = new Cancel(message); // 先赋值一个reasonCancel对象的实例\r\n            // 然后执行promise的resolve\r\n            resolvePromise(_this.reason);\r\n        });\r\n    }\r\n    /**\r\n     * source静态方法，返回结果是CancelTokenSource类型,\r\n     * 一个工厂方法\r\n     */\r\n    CancelToken.source = function () {\r\n        // 定义一个cancel变量,cancel不为空\r\n        var cancel;\r\n        // 实例化一个cancelToken,传入的回调函数的c方法就是cancel方法\r\n        var token = new CancelToken(function (c) {\r\n            cancel = c; // 然后把这个c函数赋值给cancel\r\n        });\r\n        return {\r\n            token: token,\r\n            cancel: cancel\r\n        };\r\n    };\r\n    /**\r\n     * 如果再次使用Cancel（就是已经取消过）抛出异常的方法\r\n     */\r\n    CancelToken.prototype.throwIfRequested = function () {\r\n        // 当this.reason方法不为空的情况下就是执行了executor方法，这时候就不能执行了\r\n        if (this.reason) {\r\n            throw this.reason;\r\n        }\r\n    };\r\n    return CancelToken;\r\n}());\r\nexport default CancelToken;\r\n//# sourceMappingURL=CancelToken.js.map","dts":{"name":"/Users/liu/Desktop/StrLiu/WebMaterial/Typescript-project/axios-typescript/dist/types/cancel/CancelToken.d.ts","writeByteOrderMark":false,"text":"import { CancelToken as CancelTokenInterface, CancelExecutor, CancelTokenSource } from '../types';\r\nimport Cancel from './Cancel';\r\n/**\r\n * 取消token的类\r\n */\r\nexport default class CancelToken implements CancelTokenInterface {\r\n    promise: Promise<Cancel>;\r\n    reason?: Cancel;\r\n    constructor(executor: CancelExecutor);\r\n    /**\r\n     * source静态方法，返回结果是CancelTokenSource类型,\r\n     * 一个工厂方法\r\n     */\r\n    static source(): CancelTokenSource;\r\n    /**\r\n     * 如果再次使用Cancel（就是已经取消过）抛出异常的方法\r\n     */\r\n    throwIfRequested(): void;\r\n}\r\n"}}
